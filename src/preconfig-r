#!/usr/bin/perl
# -*- perl -*-

# -----------------------------------------------------------------------
#
#  pre-config.pl
#
#  process %grid, %time, %parallel and writes config.<n> files
#
# -----------------------------------------------------------------------
#
# syntax pre-config <cfg-file>
#
# -----------------------------------------------------------------------
#
# This is a sample of a <cfg-file> required on input
#
# %grid= (
#	imax    => 100,
#	jmax    => 100,
#	kmax    => 100,
#	dx      => 1,
#	dy      => 1,
#	dz      => 1	
#	);
#
# %pml = (
#	cells   => 8,
#	pot     => 3,
#	sigma   => 3.,
#	kappa   => 1.,
#	i0      => 1,   i1     => 1,
#	j0      => 1,   j1     => 1,
#	k0      => 1,   k1     => 1,
#	);
#
# %time= (
#	dt      => 1,
#	ncycmax => 1000
#	);
#
# %partition= (
#	 pmlpenalty   => 2.0,
#        numproc      => 3,
#        );
#
# %epsilon= (
#
# );
#
# -----------------------------------------------------------------------
#
# config.<n> files are generated on output, sample:
#
# 1000            ! ncycmax
# 1               ! dt
# 0 99            ! irange
# 0 99            ! jrange
# 0 27            ! krange
# 1               ! this is a k-pml partition
# 1 1 1 1 1 0     ! active pmls
# 8               ! pml cells
# 3               ! pml pot parameter
# 3               ! pml sigma parameter
# 1               ! pml kappa parameter
#

use material;


$file = $ARGV[0];
do $file || die("$@");

# override number of processes
if ( defined $ARGV[1] and  $ARGV[1]>0 ) { $partition{numproc}=$ARGV[1]; }

if ( defined $partition{numproc} ) {
    $nproc = $partition{numproc};
} else { 
    $nproc = 1;
}


#  note: this is for pml on both sides
#
#  we cut the domain [0,imax-1],[0,jmax-1],[0,kmax-1] into p=numproc k-slices.
# 
#  we have: (p-2) * n + 2 * (m+l) = N 
#  
#  where p = numproc, N = kmax, n = cells per interior partition, 
#        m = normal cells in boundary partition,
#        l = pml cells in boundary partition.
#
#        z = T_l/T_m = pml penalty, ratio of time spend to calculate pml cells to normal cells
#
#  and    : n = m + l * z 
#  
#  result: n = N/p + 2 * ( z - 1 )/p * l
#  

$imax = $grid{imax};
$jmax = $grid{jmax};
$kmax = $grid{kmax};

$p = $nproc;
$z = $partition{pmlpenalty};
$l = $pml{cells};

$num_kpml = $pml{k0} + $pml{k1};  # this is either 0 or 1 or 2

$slice_n = $kmax / $p + $num_kpml * ( $z - 1. ) / $p * $l;
$slice_m = $slice_n - $z * $l;

$islice_n = int($slice_n);
$islice_m = int($slice_m);

if ( $islice_m < 1 ) { die("Partitioning failed: boundary paritions too small"); }

$left_over_cells = $kmax - $islice_n * ($p-$num_kpml) - ( $islice_m + $l ) * $num_kpml;

# we calculate thickness for each slice. left-over cells will be distributed over all cells.

for ( $kp = 0; $kp < $nproc; $kp++ ) { 

    if ( ( $kp eq 0 ) and ( $pml{k0} eq 1 ) ) { 
	$thickness[$kp] = $islice_m + $l; 
    } elsif ( ( $kp eq $nproc-1 ) and ( $pml{k1} eq 1 ) ) { 
	$thickness[$kp] = $islice_m + $l; 
    } else {  
	$thickness[$kp] = $islice_n; 
    }
    if ( $left_over_cells > 0 ) { $thickness[$kp]++; $left_over_cells--; }
}

if ( $left_over_cells > 0 ) { die("Partitioning failed: left_over_cells = $left_over_cells > 0"); }

if ( $nproc eq 1 ) {
    $thickness[0] = $kmax;
}

$iend = $grid{imax} - 1;
$jend = $grid{jmax} - 1;
$kend = $grid{kmax} - 1;
$ncycmax = $time{ncycmax};
$dt = $time{dt};


# ----- create grid.<n>.in files

print "pre-config: writes grid config files\n";

open (FH,"> grid.in");
    
print FH "$nproc\t\t! number of partitions\n";
print FH "$ncycmax\t\t! ncycmax\n";
print FH "$dt\t\t! dt\n";
print FH "0 $iend\t\t! irange\n";
print FH "0 $jend\t\t! jrange\n";
print FH "0 $kend\t\t! krange\n";
 
close(FH);
  
$kstart = 0;

for ($kp=0; $kp<$nproc; $kp++ ) { # loop over paritions

    open (FH,"> grid.$kp.in");
    
    $kend = $kstart + $thickness[$kp]-1; 

    print FH "$nproc\t\t! number of partitions\n";
    print FH "$ncycmax\t\t! ncycmax\n";
    print FH "$dt\t\t! dt\n";
    print FH "0 $iend\t\t! irange\n";
    print FH "0 $jend\t\t! jrange\n";
    print FH "$kstart $kend\t\t! krange\n";

    $kstart = $kend + 1;
    
    close(FH);
}


# ----- create pml.in file

print "pre-config: writes pml config files\n";

open (FH,"> pml.in");

$pmlk = $pml{k0} + $pml{k1};
print FH "$pmlk\t\t! this is a k-pml partition\n";
print FH "$pml{i0} $pml{i1} $pml{j0} $pml{j1} $pml{k0} $pml{k1}\t! active pmls\n";
print FH "$pml{cells}\t\t! pml cells\n";
print FH "$pml{pot}\t\t! pml pot parameter\n";
print FH "$pml{sigma}\t\t! pml sigma parameter\n";
print FH "$pml{kappa}\t\t! pml kappa parameter\n";

$kstart = 0;

for ($kp=0; $kp<$nproc; $kp++ ) { # loop over paritions

    open (FH,"> pml.$kp.in");
    
    $pmlk0 = 0;
    $pmlk1 = 0;
    if ( $kp eq 0 and $pml{k0} eq 1 ) { 
	$pmlk0 = $pml{k0};
    } 
    if ( $kp eq $nproc-1 and $pml{k1} eq 1 ) {
	$pmlk1 = $pml{k1};
    }
    $pmlk = $pmlk0 + $pmlk1 ;
    if ( $pmlk > 0 ) {
	print FH "$pmlk\t\t! this is a k-pml partition\n";
    } else {
	print FH "0\t\t! this is a non k-pml partition\n";
    }
    print FH "$pml{i0} $pml{i1} $pml{j0} $pml{j1} $pmlk0 $pmlk1\t! active pmls\n";
    print FH "$pml{cells}\t\t! pml cells\n";
    print FH "$pml{pot}\t\t! pml pot parameter\n";
    print FH "$pml{sigma}\t\t! pml sigma parameter\n";
    print FH "$pml{kappa}\t\t! pml kappa parameter\n";
    $kstart = $kend + 1;
    
    close(FH);
}



# ----- create epsilon.in file

print "pre-config: writes obj-epsilon.in\n";

open (FH,"> obj-epsilon.in");
material::write_epsilon_1(\*FH);
close (FH);


# ----- create output.in file

print "pre-config: writes output.in\n";

open(FH,">output.in");

foreach $label ( %GPL ) {
    $ref = $GPL{$label};
    if ( defined  $$ref{type} ) {
	print FH "\n(OUTGPL\n";
	print FH "$label $$ref{type}\n";
	print FH "$$ref{n0} $$ref{n1} $$ref{dn}\n";
	print FH "$$ref{i0} $$ref{i1} $$ref{di}\n";
	print FH "$$ref{j0} $$ref{j1} $$ref{dj}\n";
	print FH "$$ref{k0} $$ref{k1} $$ref{dk}\n";
	print FH ")\n";
    }
}


foreach $label ( %TFSF ) {
    $ref = $TFSF{$label};
    if ( defined  $$ref{file} ) {
	print FH "\n(TFSF\n";
	print FH "$label\n";
	print FH "$$ref{file}\n";
	print FH "$$ref{i0} $$ref{j0} $$ref{k0}\n";
	print FH "$$ref{ic} $$ref{jc}\n";
	print FH "$$ref{latc}\n";
	print FH "$$ref{om} $$ref{t0} $$ref{gam}\n";
	print FH ")\n";
    }
}

close(FH);


# ----- execute further serial preprocessor scripts


foreach $f ( @pre_exec ) {
    print "pre-config: executing $f\n";
    if ( system("$f") != 0) { print "failed!\n"; }
}



exit(0);






