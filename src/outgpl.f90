!----------------------------------------------------------------------
!
!  module: outgpl-r
!
!  ascii outgpl module.
!
!  subs:
!
!  
!
!----------------------------------------------------------------------

! ---------------------------------------------------------------------
!     Supported Data: Ex, Ey, Ez, Hx, Hy, Hz, Di, Px, Py, Pz, En
! ---------------------------------------------------------------------
!     Contained Subroutines:
!
!     InitOutgplParameters
!     WriteOutgplHeader
!     InitOutgpl             used in max3d.f90
!     Outgpl(ncyc)           used in max3d.f90
!            WriteEH
!            WriteComp
!            WriteDi
!            WriteData
!     DataPrepOutgpl(ncyc)   used in max3d.f90 (between StepH and StepE)
!     LoadPx
!     LoadPy
!     LoadPz

! ---------------------------------------------------------------------

!  outgpl mode 'abcd':
!  ab = component(s) 'Ex', 'Ey', 'Ez', 'Hx', 'Hy','Hz','EH','Di',
!                     'En', 'Px', 'Py', oder 'Pz'
!  c = 'E':  one file (for all time steps)
!  c = 'M':  multiple files
!  d = 'R':  spatially resolved outgpl
!  d = 'S':  spatially integrated outgpl

!  Spatial and temporal localization of the components in (i,j,k,ncyc):
!  Ex-Ez: (i+1/2,j,k,GT) - (i,j,k+1/2,GT)  
!  Hx-Hz: (i,j+1/2,k+1/2,GT-0.5*DT) - (i+1/2,j+1/2,k,GT-0.5*DT)
!  EH = (Ex,Ey,Ez,Hx,Hy,Hz): as above
!  Di = diectric constant: (i,j,k)
!  Energy En:  electric part EnE: (i,j,k,GT)
!              magnetic part EnM: (i,j,k,GT-0.5*DT)
!              En = EnE + EnM
!  Px-Pz:  (i+1/2,j,k,GT-0.5*DT) - (i,j,k+1/2,GT-0.5*DT)  
! ---------------------------------------------------------------------


module outgpl

  use constant
  use strings
  use mpiworld
  use grid  

  implicit none
  save

  ! --- Constants

  character(len=255), parameter :: pfxoutgpl = 'outgpl'
  integer, parameter :: PARTSMAXGPL = 100

  ! --- Types

  type T_OUTBAS 

     ! Outgpl files:
     character(STRLNG) fn

     ! Outgpl mode:
     character(len=10) :: Mode

     ! Spatial area
     integer ns, ne, dn
     integer is, ie, di
     integer js, je, dj
     integer ks, ke, dk

     ! Other
     integer idx
     integer NumNodes

  end type T_OUTBAS

  ! --- Variables

  type(T_OutBas) :: gpl(PARTSMAXGPL)
  integer :: partsgpl


contains


  subroutine InitializeOutgpl

    use constant
    implicit none

    integer ::  ios,n,i,err
    character(len=STRLNG) :: file, str

    call ReadConfig(gpl)
    call WriteHeader(gpl)

  contains
  
    subroutine ReadConfig(gpl)
      
      implicit none

      type(T_OutBas) :: gpl(PARTSMAXGPL)      

      character(len=STRLNG) :: file

      file=cat2(pfxoutgpl,sfxin)
      
      open(UNITTMP,FILE=file,STATUS='unknown')
      n = 0
      do
         read(UNITTMP,IOSTAT=ios,FMT=*) str
         if(ios .ne. 0) exit
         if(str(1:4).eq. '#ASC') then
            n = n+1
            call ReadConfigObject(gpl(n))
            gpl(n)%idx = n  
            if(n .ge. PARTSMAXGPL) exit
         endif
      enddo
      close(UNITTMP)
      partsgpl=n  
      
    end subroutine ReadConfig


    subroutine WriteHeader(gpl)

      implicit none

      type(T_OutBas) :: gpl(PARTSMAXGPL)

      do n=1, partsgpl
         open(UNITTMP,FILE=gpl(n)%fn,STATUS='unknown')      
         call WriteHeaderObject(gpl(n))
         close(UNITTMP)           
      enddo

    end subroutine WriteHeader


    subroutine ReadConfigObject(this)

      implicit none
      
      type (T_OUTBAS) :: this
      integer UNITTMP, isteps, jsteps, ksteps

      ! Read Modul (Type) Data
      read(UNITTMP,*) this%fn, this%Mode
      read(UNITTMP,*) this%ns, this%ne, this%dn
      read(UNITTMP,*) this%is, this%ie, this%di
      read(UNITTMP,*) this%js, this%je, this%dj
      read(UNITTMP,*) this%ks, this%ke, this%dk

      this%fn = cat2(this%fn, mpi_sfxout)
      
      ! check ranges	
      this%is = max(IBEG, this%is); 
      this%ie = min(IEND, this%ie);
      
      this%js = max(JBEG, this%js); 
      this%je = min(JEND, this%je);
      
      this%ks = max(KBEG, this%ks); 
      this%ke = min(KEND, this%ke);
      
      isteps = max(int((this%ie-this%is+this%di)/this%di),0)
      jsteps = max(int((this%je-this%js+this%dj)/this%dj),0)
      jsteps = max(int((this%ke-this%ks+this%dk)/this%dk),0)
      this%NumNodes = isteps*jsteps*ksteps
      
    end subroutine ReadConfigObject

    subroutine WriteHeaderObject(this)
      
      implicit none
      
      type (T_OUTBAS) :: this
      real(8) :: ts,te,xs,xe,ys,ye,zs,ze
      
      ts = this%ns*DT+GT
      te = this%ne*DT+GT
      xs = this%is*SX
      xe = this%ie*SX
      ys = this%js*SY
      ye = this%je*SY
      zs = this%ks*SZ
      ze = this%ke*SZ
      
      ! Write Data in File Header
      write(UNITTMP,'(A1,A30)') '# Generated by Outgpl module'
!      write(UNITTMP,'(A1,A30)') '#','label1'
!      write(UNITTMP,'(A1,A30)') '#','label2'
!      write(UNITTMP,'(A1,A30)') '#','label3'
!      write(UNITTMP,'(A1,A30)') '#','label4'
!      write(UNITTMP,'(A1,A30)') '#','label5'
!      write(UNITTMP,'(A1,A30)') '#','label6'
      write(UNITTMP,'(A1,A30,A4)') '#',this%fn(1:27),this%Mode
      write(UNITTMP,'(A1,3I8)') '#',this%ns,this%ne,this%dn
      write(UNITTMP,'(A1,2E15.6E3)') '#',ts,te
      write(UNITTMP,'(A1,3I8)') '#',this%is,this%ie,this%di
      write(UNITTMP,'(A1,2E15.6E3)') '#',xs,xe
      write(UNITTMP,'(A1,3I8)') '#',this%js,this%je,this%dj
      write(UNITTMP,'(A1,2E15.6E3)') '#',ys,ye
      write(UNITTMP,'(A1,3I8)') '#',this%ks,this%ke,this%dk
      write(UNITTMP,'(A1,2E15.6E3)') '#',zs,ze

    end subroutine WriteHeaderObject


  end subroutine InitializeOutgpl


  subroutine FinalizeOutgpl
    implicit none


  end subroutine FinalizeOutgpl

  subroutine OpenOutgpl(this, ncyc, ret)

    
    type (T_OUTBAS) :: this
    integer :: ncyc
    logical :: ret

    integer :: ios
    character(len=STRLNG) :: fn, fnh

    ret = .False.
    ! outgpl ?
    if(mod(ncyc, this%dn) .eq. 0 .and. &
         ncyc .ge. this%ns       .and. &
         ncyc .le. this%ne ) then
       
       ! open file
       if( this%Mode(3:3) .eq. 'M') then
          fn = this%fn
          write(fnh,*) ncyc     
          fnh=adjustl(fnh)
          fn((len_trim(fn)+1):STRLNG) = fnh         
          open(UNITTMP,IOSTAT=ios, FILE=fn) 
       else
          fn = this%fn
          open(UNITTMP,IOSTAT=ios,POSITION= "APPEND", FILE=fn) 
       endif
       ret = .True.
    endif
    
  end subroutine OpenOutgpl

  subroutine CloseOutgpl

    close(UNITTMP)

  end subroutine CloseOutgpl


end module outgpl
